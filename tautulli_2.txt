    def get_newsletter_config(self, newsletter_id=None):
        """
        Get the configuration for an existing notification agent.

        Required parameters:
            newsletter_id (int):        The newsletter config to retrieve

        Optional parameters:
            None

        Returns:
            json:
                {"id": 1,
                 "agent_id": 0,
                 "agent_name": "recently_added",
                 "agent_label": "Recently Added",
                 "friendly_name": "",
                 "id_name": "",
                 "cron": "0 0 * * 1",
                 "active": 1,
                 "subject": "Recently Added to {server_name}! ({end_date})",
                 "body": "View the newsletter here: {newsletter_url}",
                 "message": "",
                 "config": {"custom_cron": 0,
                            "filename": "newsletter_{newsletter_uuid}.html",
                            "formatted": 1,
                            "incl_libraries": ["1", "2"],
                            "notifier_id": 1,
                            "save_only": 0,
                            "time_frame": 7,
                            "time_frame_units": "days"
                            },
                 "email_config": {...},
                 "config_options": [{...}, ...],
                 "email_config_options": [{...}, ...]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_newsletter_config',
            'newsletter_id': newsletter_id                      # (int)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(newsletter_id, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_newsletter_log(self, order_column=None, order_dir=None,
                           start=None, length=None, search=None):
        """
        Get the data on the Tautulli newsletter logs table.

        Required parameters:
            None

        Optional parameters:
            order_column (str):             "timestamp", "newsletter_id",
                                            "agent_name", "notify_action",
                                            "subject_text", "start_date",
                                            "end_date", "uuid"
            order_dir (str):                "desc" or "asc"
            start (int):                    Row to start from, 0
            length (int):                   Number of items to return, 25
            search (str):                   A string to search for, "Telegram"

        Returns:
            json:
                {"draw": 1,
                 "recordsTotal": 1039,
                 "recordsFiltered": 163,
                 "data":
                    [{"agent_id": 0,
                      "agent_name": "recently_added",
                      "end_date": "2018-03-18",
                      "id": 7,
                      "newsletter_id": 1,
                      "notify_action": "on_cron",
                      "start_date": "2018-03-05",
                      "subject_text": "Recently Added to Plex
                                      (Winterfell-Server)! (2018-03-18)",
                      "success": 1,
                      "timestamp": 1462253821,
                      "uuid": "7fe4g65i"
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_newsletter_log',
            'order_column': order_column,                       # (str)
            'order_dir': order_dir,                             # (str)
            'start': start,                                     # (int)
            'length': length,                                   # (int)
            'search': search                                    # (str)
        }

        order_column_list = ["timestamp", "newsletter_id", "agent_name",
                             "notify_action", "subject_text", "start_date",
                             "end_date", "uuid"]
        order_dir_list = ["desc", "asc"]

        # Check keyword arguments
        utils.check_str_kw(order_column, order_column_list,
                           is_required=False)
        utils.check_str_kw(order_dir, order_dir_list,
                           is_required=False)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_pos_int_kw(length, is_required=False)
        utils.check_str_kw(search, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_newsletters(self):
        """
        Get a list of configured newsletters.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"id": 1,
                  "agent_id": 0,
                  "agent_name": "recently_added",
                  "agent_label": "Recently Added",
                  "friendly_name": "",
                  "cron": "0 0 * * 1",
                  "active": 1
                  }
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_newsletters'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_notification_log(self, order_column=None, order_dir=None,
                             start=None, length=None, search=None):
        """
        Get the data on the Tautulli notification logs table.

        Required parameters:
            None

        Optional parameters:
            order_column (str):             "timestamp", "notifier_id",
                                            "agent_name", "notify_action",
                                            "subject_text", "body_text"
            order_dir (str):                "desc" or "asc"
            start (int):                    Row to start from, 0
            length (int):                   Number of items to return, 25
            search (str):                   A string to search for, "Telegram"

        Returns:
            json:
                {"draw": 1,
                 "recordsTotal": 1039,
                 "recordsFiltered": 163,
                 "data":
                    [{"agent_id": 13,
                      "agent_name": "telegram",
                      "body_text": "DanyKhaleesi69 started playing
                                   The Red Woman.",
                      "id": 1000,
                      "notify_action": "on_play",
                      "rating_key": 153037,
                      "session_key": 147,
                      "subject_text": "Tautulli (Winterfell-Server)",
                      "success": 1,
                      "timestamp": 1462253821,
                      "user": "DanyKhaleesi69",
                      "user_id": 8008135
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_notification_log',
            'order_column': order_column,                       # (str)
            'order_dir': order_dir,                             # (str)
            'start': start,                                     # (int)
            'length': length,                                   # (int)
            'search': search                                    # (str)
        }

        order_column_list = ["timestamp", "notifier_id", "agent_name",
                             "notify_action", "subject_text", "body_text"]
        order_dir_list = ["desc", "asc"]

        # Check keyword arguments
        utils.check_str_kw(order_column, order_column_list,
                           is_required=False)
        utils.check_str_kw(order_dir, order_dir_list,
                           is_required=False)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_pos_int_kw(length, is_required=False)
        utils.check_str_kw(search, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_notifier_config(self, notifier_id=None):
        """
        Get the configuration for an existing notification agent.

        Required parameters:
            notifier_id (int):        The notifier config to retrieve

        Optional parameters:
            None

        Returns:
            json:
                {"id": 1,
                 "agent_id": 13,
                 "agent_name": "telegram",
                 "agent_label": "Telegram",
                 "friendly_name": "",
                 "config": {"incl_poster": 0,
                            "html_support": 1,
                            "chat_id": "123456",
                            "bot_token": "13456789:fio9040NNo04jLEp-4S",
                            "incl_subject": 1,
                            "disable_web_preview": 0
                            },
                 "config_options": [{...}, ...]
                 "actions": {"on_play": 0,
                             "on_stop": 0,
                             ...
                             },
                 "notify_text": {"on_play": {"subject": "...",
                                             "body": "..."
                                             }
                                 "on_stop": {"subject": "...",
                                             "body": "..."
                                             }
                                 ...
                                 }
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_notifier_config',
            'notifier_id': notifier_id                          # (int)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(notifier_id, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_notifier_parameters(self):
        """
        Get the list of available notification parameters.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                {
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_notifier_parameters'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_notifiers(self, notify_action=None):
        """
        Get a list of configured notifiers.

        Required parameters:
            None

        Optional parameters:
            notify_action (str):        The notification action to filter out

        Returns:
            json:
                [{"id": 1,
                  "agent_id": 13,
                  "agent_name": "telegram",
                  "agent_label": "Telegram",
                  "friendly_name": "",
                  "active": 1
                  }
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_notifiers',
            'notify_action': notify_action                      # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(notify_action, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_old_rating_keys(self, rating_key=None, media_type=None):
        """
        Get a list of old rating keys from the Tautulli database for all
        of the item's parent/children.

        Required parameters:
            rating_key (str):       '12345'
            media_type (str):       "movie", "show", "season",
                                    "episode", "artist", "album",
                                    "track"

        Optional parameters:
            None

        Returns:
            json:
                {}
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_old_rating_keys',
            'rating_key': rating_key,                           # (str)
            'media_type': media_type                            # (str)
        }

        media_type_list = ['movie', 'show', 'season', 'episode', 'artist',
                           'album', 'track']

        # Check keyword arguments
        utils.check_str_kw(rating_key, is_required=True)
        utils.check_str_kw(media_type, media_type_list,
                           is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_date(self, time_range=None, y_axis=None, user_id=None,
                          grouping=None):
        """
        Get graph data by date.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (int):         0 or 1

        Returns:
            json:
                {"categories":
                    ["YYYY-MM-DD", "YYYY-MM-DD", ...]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_date',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_dayofweek(self, time_range=None, y_axis=None,
                               user_id=None, grouping=None):
        """
        Get graph data by day of the week.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (int):         0 or 1

        Returns:
            json:
                {"categories":
                    ["Sunday", "Monday", "Tuesday", ..., "Saturday"]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_dayofweek',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_hourofday(self, time_range=None, y_axis=None,
                               user_id=None, grouping=None):
        """
        Get graph data by hour of the day.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["00", "01", "02", ..., "23"]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_hourofday',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_source_resolution(self, time_range=None, y_axis=None,
                                       user_id=None, grouping=None):
        """
        Get graph data by source resolution.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["720", "1080", "sd", ...]
                 "series":
                    [{"name": "Direct Play", "data": [...]}
                     {"name": "Direct Stream", "data": [...]},
                     {"name": "Transcode", "data": [...]}
                     ]
                 }
        """
        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_source_resolution',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_stream_resolution(self, time_range=None, y_axis=None,
                                       user_id=None, grouping=None):
        """
        Get graph data by stream resolution.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["720", "1080", "sd", ...]
                 "series":
                    [{"name": "Direct Play", "data": [...]}
                     {"name": "Direct Stream", "data": [...]},
                     {"name": "Transcode", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_stream_resolution',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_stream_type(self, time_range=None, y_axis=None,
                                 user_id=None, grouping=None):
        """
        Get graph data by stream type by date.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["YYYY-MM-DD", "YYYY-MM-DD", ...]
                 "series":
                    [{"name": "Direct Play", "data": [...]}
                     {"name": "Direct Stream", "data": [...]},
                     {"name": "Transcode", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_stream_type',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_top_10_platforms(self, time_range=None, y_axis=None,
                                      user_id=None, grouping=None):
        """
        Get graph data by top 10 platforms.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["iOS", "Android", "Chrome", ...]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_top_10_platforms',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_by_top_10_users(self, time_range=None, y_axis=None,
                                  user_id=None, grouping=None):
        """
        Get graph data by top 10 users.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["Jon Snow", "DanyKhaleesi69", "A Girl", ...]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_by_top_10_users',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plays_per_month(self, time_range=None, y_axis=None,
                            user_id=None, grouping=None):
        """
        Get graph data by month.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of months of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["Jan 2016", "Feb 2016", "Mar 2016", ...]
                 "series":
                    [{"name": "Movies", "data": [...]}
                     {"name": "TV", "data": [...]},
                     {"name": "Music", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plays_per_month',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_plex_log(self, window=None, log_type=None):
        """
        Get the PMS logs.

        Required parameters:
            None

        Optional parameters:
            window (int):           The number of tail lines to return
            log_type (str):         "server" or "scanner"

        Returns:
            json:
                [["May 08, 2016 09:35:37",
                  "DEBUG",
                  "Auth: Came in with a super-token, authorization succeeded."
                  ],
                 [...],
                 [...]
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_plex_log',
            'window': window,                                   # (int)
            'log_type': log_type                                # (str)
        }

        log_type_list = ['server', 'scanner']

        # Check keyword arguments
        utils.check_pos_int_kw(window, is_required=False)
        utils.check_str_kw(log_type, log_type_list, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_pms_token(self, username=None, password=None):
        """
        Get the user's Plex token used for Tautulli.

        Required parameters:
            username (str):     The Plex.tv username
            password (str):     The Plex.tv password

        Optional parameters:
            None

        Returns:
            string:             The Plex token used for Tautulli
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_pms_token',
            'username': username,                               # (str)
            'password': password                                # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(username, is_required=True)
        utils.check_str_kw(password, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_pms_update(self):
        """
        Check for updates to the Plex Media Server.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                {"update_available": true,
                 "platform": "Windows",
                 "release_date": "1473721409",
                 "version": "1.1.4.2757-24ffd60",
                 "requirements": "...",
                 "extra_info": "...",
                 "changelog_added": "...",
                 "changelog_fixed": "...",
                 "label": "Download",
                 "distro": "english",
                 "distro_build": "windows-i386",
                 "download_url": "https://downloads.plex.tv/...",
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_pms_update'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_recently_added(self, count=25, start=None, media_type=None,
                           section_id=None):
        """
        Get all items that where recently added to plex.

        Required parameters:
            count (int):        Number of items to return (default=25)

        Optional parameters:
            start (int):        The item number to start at
            media_type (str):   The media type:
                                "movie", "show", "artist"
            section_id (int):   The id of the Plex library section

        Returns:
            json:
                {"recently_added":
                    [{"added_at": "1461572396",
                      "grandparent_rating_key": "1219",
                      "grandparent_thumb":
                          "/library/metadata/1219/thumb/1462175063",
                      "grandparent_title": "Game of Thrones",
                      "library_name": "",
                      "media_index": "1",
                      "media_type": "episode",
                      "original_title": "",
                      "parent_media_index": "6",
                      "parent_rating_key": "153036",
                      "parent_thumb":
                          "/library/metadata/153036/thumb/1462175062",
                      "parent_title": "",
                      "rating_key": "153037",
                      "section_id": "2",
                      "thumb": "/library/metadata/153037/thumb/1462175060",
                      "title": "The Red Woman",
                      "year": "2016"
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_recently_added',
            'count': count,                                     # (int) (req)
            'start': start,                                     # (int)
            'type': media_type,                                 # (str)
            'section_id': section_id                            # (int)
        }

        media_type_list = ["movie", "show", "artist"]

        # Check keyword arguments
        utils.check_pos_int_kw(count, is_required=True)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_str_kw(media_type, media_type_list,
                           is_required=False)
        utils.check_pos_int_kw(section_id, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_server_friendly_name(self):
        """
        Get the name of the PMS.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            string:     "Winterfell-Server"
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_server_friendly_name'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_server_id(self, hostname='localhost', port=32400, ssl=None,
                      remote=None):
        """
        Get the PMS server identifier.

        Required parameters:
            hostname (str):     'localhost' or '192.160.0.10'
            port (int):         32400

        Optional parameters:
            ssl (bin):          0 or 1
            remote (bin):       0 or 1

        Returns:
            json:
                {'identifier': '08u2phnlkdshf890bhdlksghnljsahgleikjfg9t'}
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_server_id',
            'hostname': hostname,                               # (str) (req)
            'port': port,                                       # (int) (req)
            'ssl': ssl,                                         # (bin)
            'remote': remote                                    # (bin)
        }

        # Check keyword arguments
        utils.check_str_kw(hostname, is_required=True)
        utils.check_pos_int_kw(port, is_required=True)
        utils.check_bin_kw(ssl, is_required=False)
        utils.check_bin_kw(remote, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_server_identity(self):
        """
        Get info about the local server.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"machine_identifier": "ds48g4r354a8v9byrrtr697g3g79w",
                  "version": "0.9.15.x.xxx-xxxxxxx"
                  }
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_server_identity'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_server_list(self):
        """
        Get all your servers that are published to Plex.tv.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"clientIdentifier": "ds48g4r354a8v9byrrtr697g3g79w",
                  "httpsRequired": "0",
                  "ip": "xxx.xxx.xxx.xxx",
                  "label": "Winterfell-Server",
                  "local": "1",
                  "port": "32400",
                  "value": "xxx.xxx.xxx.xxx"
                  },
                 {...},
                 {...}
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_server_list'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_server_pref(self, pref=None):
        """
        Get a specified PMS server preference.

        Required parameters:
            pref (str):         Name of preference

        Returns:
            string:             Value of preference
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_server_pref',
            'pref': pref                                        # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(pref, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_servers_info(self):
        """
        Get info about the PMS.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"port": "32400",
                  "host": "10.0.0.97",
                  "version": "0.9.15.2.1663-7efd046",
                  "name": "Winterfell-Server",
                  "machine_identifier": "ds48g4r354a8v9byrrtr697g3g79w"
                  }
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_servers_info'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_settings(self, key=None):
        """
        Gets all settings from the config file.

        Required parameters:
            None

        Optional parameters:
            key (str):      Name of a config section to return

        Returns:
            json:
                {"General": {"api_enabled": true, ...}
                 "Advanced": {"cache_sizemb": "32", ...},
                 ...
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_settings',
            'key': key                                          # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(key, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_stream_data(self, row_id=None, session_key=None):
        """
        Get the stream details from history or current stream.

        Required parameters:
            row_id (int):       The row ID number for the history item, OR
            session_key (int):  The session key of the current stream

        Optional parameters:
            None

        Returns:
            json:
                {"aspect_ratio": "2.35",
                 "audio_bitrate": 231,
                 "audio_channels": 6,
                 "audio_codec": "aac",
                 "audio_decision": "transcode",
                 "bitrate": 2731,
                 "container": "mp4",
                 "current_session": "",
                 "grandparent_title": "",
                 "media_type": "movie",
                 "optimized_version": "",
                 "optimized_version_profile": "",
                 "optimized_version_title": "",
                 "original_title": "",
                 "pre_tautulli": "",
                 "quality_profile": "1.5 Mbps 480p",
                 "stream_audio_bitrate": 203,
                 "stream_audio_channels": 2,
                 "stream_audio_codec": "aac",
                 "stream_audio_decision": "transcode",
                 "stream_bitrate": 730,
                 "stream_container": "mkv",
                 "stream_container_decision": "transcode",
                 "stream_subtitle_codec": "",
                 "stream_subtitle_decision": "",
                 "stream_video_bitrate": 527,
                 "stream_video_codec": "h264",
                 "stream_video_decision": "transcode",
                 "stream_video_framerate": "24p",
                 "stream_video_height": 306,
                 "stream_video_resolution": "SD",
                 "stream_video_width": 720,
                 "subtitle_codec": "",
                 "subtitles": "",
                 "synced_version": "",
                 "synced_version_profile": "",
                 "title": "Frozen",
                 "transcode_hw_decoding": "",
                 "transcode_hw_encoding": "",
                 "video_bitrate": 2500,
                 "video_codec": "h264",
                 "video_decision": "transcode",
                 "video_framerate": "24p",
                 "video_height": 816,
                 "video_resolution": "1080",
                 "video_width": 1920
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_stream_data',
            'row_id': row_id,                                   # (int)
            'session_key': session_key                          # (int)
        }

        # Check for ONLY one required arguments
        if row_id and session_key is None:
            raise ValueError(
                'Either "row_id" OR "session_key" is required'
            )
        elif row_id and session_key is not None:
            raise ValueError(
                'Only ONE required argument ("row_id" OR "session_key") '
                'is required'
            )
        elif row_id is not None:
            utils.check_pos_int_kw(row_id)
        elif session_key is not None:
            utils.check_pos_int_kw(session_key)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_stream_type_by_top_10_platforms(self, time_range=None,
                                            y_axis=None, user_id=None,
                                            grouping=None):
        """
        Get graph data by stream type by top 10 platforms.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["iOS", "Android", "Chrome", ...]
                 "series":
                    [{"name": "Direct Play", "data": [...]}
                     {"name": "Direct Stream", "data": [...]},
                     {"name": "Transcode", "data": [...]}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_stream_type_by_top_10_platforms',
            'time_range': time_range,                               # (str)
            'y_axis': y_axis,                                       # (str)
            'user_id': user_id,                                     # (str)
            'grouping': grouping                                    # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_stream_type_by_top_10_users(self, time_range=None, y_axis=None,
                                        user_id=None, grouping=None):
        """
        Get graph data by stream type by top 10 users.

        Required parameters:
            None

        Optional parameters:
            time_range (str):       The number of days of data to return
            y_axis (str):           "plays" or "duration"
            user_id (str):          The user id to filter the data
            grouping (bin):         0 or 1

        Returns:
            json:
                {"categories":
                    ["Jon Snow", "DanyKhaleesi69", "A Girl", ...]
                 "series":
                    [{"name": "Direct Play", "data": [...]}
                     {"name": "Direct Stream", "data": [...]},
                     {"name": "Transcode", "data": [...]}
                    ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_stream_type_by_top_10_users',
            'time_range': time_range,                           # (str)
            'y_axis': y_axis,                                   # (str)
            'user_id': user_id,                                 # (str)
            'grouping': grouping                                # (bin)
        }

        y_axis_list = ['plays', 'duration']

        # Check keyword arguments
        utils.check_str_kw(time_range, is_required=False)
        utils.check_str_kw(y_axis, y_axis_list, is_required=False)
        utils.check_str_kw(user_id, is_required=False)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_synced_items(self, machine_id=None, user_id=None):
        """
        Get a list of synced items on the PMS.

        Required parameters:
            machine_id (str):       The PMS identifier

        Optional parameters:
            user_id (str):          The id of the Plex user

        Returns:
            json:
                [{"audio_bitrate": "192",
                  "client_id": "95434se643fsf24f-com-plexapp-android",
                  "content_type": "video",
                  "device_name": "Tyrion's iPad",
                  "failure": "",
                  "item_complete_count": "1",
                  "item_count": "1",
                  "item_downloaded_count": "1",
                  "item_downloaded_percent_complete": 100,
                  "metadata_type": "movie",
                  "photo_quality": "74",
                  "platform": "iOS",
                  "rating_key": "154092",
                  "root_title": "Movies",
                  "state": "complete",
                  "sync_id": "11617019",
                  "sync_title": "Deadpool",
                  "total_size": "560718134",
                  "user": "DrukenDwarfMan",
                  "user_id": "696969",
                  "username": "DrukenDwarfMan",
                  "video_bitrate": "4000"
                  "video_quality": "100"
                  },
                 {...},
                 {...}
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_synced_items',
            'machine_id': machine_id,                           # (str) (req)
            'user_id': user_id                                  # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(machine_id, is_required=True)
        utils.check_str_kw(user_id, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user(self, user_id=None):
        """
        Get a user's details.

        Required parameters:
            user_id (str):          The id of the Plex user

        Optional parameters:
            None

        Returns:
            json:
                {"allow_guest": 1,
                 "deleted_user": 0,
                 "do_notify": 1,
                 "email": "Jon.Snow.1337@CastleBlack.com",
                 "friendly_name": "Jon Snow",
                 "is_allow_sync": 1,
                 "is_home_user": 1,
                 "is_restricted": 0,
                 "keep_history": 1,
                 "shared_libraries": ["10", "1", "4", "5", "15", "20", "2"],
                 "user_id": 133788,
                 "user_thumb": "https://plex.tv/users/k10w42309cynaopq/avatar",
                 "username": "LordCommanderSnow"
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user',
            'user_id': user_id                                  # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(user_id, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user_ips(self, user_id=None, order_column=None, order_dir=None,
                     start=None, length=None, search=None):
        """
        Get the data on Tautulli users IP table.

        Required parameters:
            user_id (str):                  The id of the Plex user

        Optional parameters:
            order_column (str):             "last_seen", "ip_address",
                                            "platform", "player",
                                            "last_played", "play_count"
            order_dir (str):                "desc" or "asc"
            start (int):                    Row to start from, 0
            length (int):                   Number of items to return, 25
            search (str):                   A string to search for,
                                            "xxx.xxx.xxx.xxx"

        Returns:
            json:
                {"draw": 1,
                 "recordsTotal": 2344,
                 "recordsFiltered": 10,
                 "data":
                    [{"friendly_name": "Jon Snow",
                      "id": 1121,
                      "ip_address": "xxx.xxx.xxx.xxx",
                      "last_played": "Game of Thrones - The Red Woman",
                      "last_seen": 1462591869,
                      "media_index": 1,
                      "media_type": "episode",
                      "parent_media_index": 6,
                      "parent_title": "",
                      "platform": "Chrome",
                      "play_count": 149,
                      "player": "Plex Web (Chrome)",
                      "rating_key": 153037,
                      "thumb": "/library/metadata/153036/thumb/1462175062",
                      "transcode_decision": "transcode",
                      "user_id": 133788,
                      "year": 2016
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user_ips',
            'user_id': user_id,                                 # (str) (req)
            'order_column': order_column,                       # (str)
            'order_dir': order_dir,                             # (str)
            'start': start,                                     # (int)
            'length': length,                                   # (int)
            'search': search                                    # (str)
        }

        order_column_list = ["last_seen", "ip_address", "platform", "player",
                             "last_played", "play_count"]
        order_dir_list = ["desc", "asc"]

        # Check keyword arguments
        utils.check_str_kw(user_id, is_required=True)
        utils.check_str_kw(order_column, order_column_list,
                           is_required=False)
        utils.check_str_kw(order_dir, order_dir_list,
                           is_required=False)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_pos_int_kw(length, is_required=False)
        utils.check_str_kw(search, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user_logins(self, user_id=None, order_column=None,
                        order_dir=None, start=None, length=None, search=None):
        """
        Get the data on Tautulli user login table.

        Required parameters:
            user_id (str):                  The id of the Plex user

        Optional parameters:
            order_column (str):             "date", "time", "ip_address",
                                            "host", "os", "browser"
            order_dir (str):                "desc" or "asc"
            start (int):                    Row to start from, 0
            length (int):                   Number of items to return, 25
            search (str):                   A string to search for,
                                            "xxx.xxx.xxx.xxx"

        Returns:
            json:
                {"draw": 1,
                 "recordsTotal": 2344,
                 "recordsFiltered": 10,
                 "data":
                    [{"browser": "Safari 7.0.3",
                      "friendly_name": "Jon Snow",
                      "host": "http://plexpy.castleblack.com",
                      "ip_address": "xxx.xxx.xxx.xxx",
                      "os": "Mac OS X",
                      "timestamp": 1462591869,
                      "user": "LordCommanderSnow",
                      "user_agent": "Mozilla/5.0 (Macintosh;
                                    Intel Mac OS X 10_9_3)
                                    AppleWebKit/537.75.14 (KHTML, like Gecko)
                                    Version/7.0.3 Safari/7046A194A",
                      "user_group": "guest",
                      "user_id": 133788
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user_logins',
            'user_id': user_id,                                 # (str) (req)
            'order_column': order_column,                       # (str)
            'order_dir': order_dir,                             # (str)
            'start': start,                                     # (int)
            'length': length,                                   # (int)
            'search': search                                    # (str)
        }

        order_column_list = ["date", "time", "ip_address", "host",
                             "os", "browser"]
        order_dir_list = ["desc", "asc"]

        # Check keyword arguments
        utils.check_str_kw(user_id, is_required=True)
        utils.check_str_kw(order_column, order_column_list,
                           is_required=False)
        utils.check_str_kw(order_dir, order_dir_list,
                           is_required=False)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_pos_int_kw(length, is_required=False)
        utils.check_str_kw(search, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user_names(self):
        """
        Get a list of all user and user ids.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"friendly_name": "Jon Snow", "user_id": 133788},
                 {"friendly_name": "DanyKhaleesi69", "user_id": 8008135},
                 {"friendly_name": "Tyrion Lannister", "user_id": 696969},
                 {...},
                ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user_names'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user_player_stats(self, user_id=None, grouping=None):
        """
        Get a user's player statistics.

        Required parameters:
            user_id (str):          The id of the Plex user

        Optional parameters:
            grouping (bin):         0 or 1

        Returns:
            json:
                [{"platform_type": "Chrome",
                  "player_name": "Plex Web (Chrome)",
                  "result_id": 1,
                  "total_plays": 170
                  },
                 {"platform_type": "Chromecast",
                  "player_name": "Chromecast",
                  "result_id": 2,
                  "total_plays": 42
                  },
                 {...},
                 {...}
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user_player_stats',
            'user_id': user_id,                                 # (str) (req)
            'grouping': grouping                                # (bin)
        }

        # Check keyword arguments
        utils.check_str_kw(user_id, is_required=True)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_user_watch_time_stats(self, user_id=None, grouping=None):
        """
        Get a user's watch time statistics.

        Required parameters:
            user_id (str):          The id of the Plex user

        Optional parameters:
            grouping (bin):         0 or 1

        Returns:
            json:
                [{"query_days": 1,
                  "total_plays": 0,
                  "total_time": 0
                  },
                 {"query_days": 7,
                  "total_plays": 3,
                  "total_time": 15694
                  },
                 {"query_days": 30,
                  "total_plays": 35,
                  "total_time": 63054
                  },
                 {"query_days": 0,
                  "total_plays": 508,
                  "total_time": 1183080
                  }
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_user_watch_time_stats',
            'user_id': user_id,                                 # (str) (req)
            'grouping': grouping                                # (bin)
        }

        # Check keyword arguments
        utils.check_str_kw(user_id, is_required=True)
        utils.check_bin_kw(grouping, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_users(self):
        """
        Get a list of all users that have access to your server.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json:
                [{"allow_guest": 1,
                  "do_notify": 1,
                  "email": "Jon.Snow.1337@CastleBlack.com",
                  "filter_all": "",
                  "filter_movies": "",
                  "filter_music": "",
                  "filter_photos": "",
                  "filter_tv": "",
                  "is_admin": 0,
                  "is_allow_sync": 1,
                  "is_home_user": 1,
                  "is_restricted": 0,
                  "keep_history": 1,
                  "server_token": "PU9cMuQZxJKFBtGqHk68",
                  "shared_libraries": "1;2;3",
                  "thumb": "https://plex.tv/users/k10w42309cynaopq/avatar",
                  "user_id": "133788",
                  "username": "Jon Snow"
                  },
                 {...},
                 {...}
                 ]
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_users'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_users_table(self, order_column=None, order_dir=None, start=None,
                        length=None, search=None):
        """
        Get the data on Tautulli users table.

        Required parameters:
            None

        Optional parameters:
            order_column (str):             "user_thumb", "friendly_name",
                                            "last_seen", "ip_address",
                                            "platform", "player",
                                            "last_played", "plays",
                                            "duration"
            order_dir (str):                "desc" or "asc"
            start (int):                    Row to start from, 0
            length (int):                   Number of items to return, 25
            search (str):                   A string to search for, "Jon Snow"

        Returns:
            json:
                {"draw": 1,
                 "recordsTotal": 10,
                 "recordsFiltered": 10,
                 "data":
                    [{"allow_guest": "Checked",
                      "do_notify": "Checked",
                      "duration": 2998290,
                      "friendly_name": "Jon Snow",
                      "id": 1121,
                      "ip_address": "xxx.xxx.xxx.xxx",
                      "keep_history": "Checked",
                      "last_played": "Game of Thrones - The Red Woman",
                      "last_seen": 1462591869,
                      "media_index": 1,
                      "media_type": "episode",
                      "parent_media_index": 6,
                      "parent_title": "",
                      "platform": "Chrome",
                      "player": "Plex Web (Chrome)",
                      "plays": 487,
                      "rating_key": 153037,
                      "thumb": "/library/metadata/153036/thumb/1462175062",
                      "transcode_decision": "transcode",
                      "user_id": 133788,
                      "user_thumb":
                          "https://plex.tv/users/568gwwoib5t98a3a/avatar",
                      "year": 2016
                      },
                     {...},
                     {...}
                     ]
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_users_table',
            'order_column': order_column,                       # (str)
            'order_dir': order_dir,                             # (str)
            'start': start,                                     # (int)
            'length': length,                                   # (int)
            'search': search                                    # (str)
        }

        order_column_list = ["user_thumb", "friendly_name", "last_seen",
                             "ip_address", "platform", "player",
                             "last_played", "plays", "duration"]
        order_dir_list = ["desc", "asc"]

        # Check keyword arguments
        utils.check_str_kw(order_column, order_column_list,
                           is_required=False)
        utils.check_str_kw(order_dir, order_dir_list,
                           is_required=False)
        utils.check_pos_int_kw(start, is_required=False)
        utils.check_pos_int_kw(length, is_required=False)
        utils.check_str_kw(search, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def get_whois_lookup(self, ip_address=None):
        """
        Get the connection info for an IP address.

        Required parameters:
            ip_address (str):               IP address of connection for
                                            whois lookup

        Optional parameters:
            None

        Returns:
            json:
                {"host": "google-public-dns-a.google.com",
                 "nets": [{"description": "Google Inc.",
                           "address": "1600 Amphitheatre Parkway",
                           "city": "Mountain View",
                           "state": "CA",
                           "postal_code": "94043",
                           "country": "United States",
                           ...
                           },
                           {...}
                          ]
            json:
                {"host": "Not available",
                 "nets": [],
                 "error": "IPv4 address 127.0.0.1 is already defined as
                          Loopback via RFC 1122, Section 3.2.1.3."
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'get_whois_lookup',
            'ip_address': ip_address                            # (str) (req)
        }

        # Check keyword arguments
        utils.check_str_kw(ip_address, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def import_database(self, app=None, database_path=None, table_name=None,
                        import_ignore_interval=None):
        """
        Import a PlexWatch or Plexivity database into Tautulli.

        Required parameters:
            app (str):                      "plexwatch" or "plexivity"
            database_path (str):            The full path to the plexwatch
                                            database file
            table_name (str):               "processed" or "grouped"

        Optional parameters:
            import_ignore_interval (int):   The minimum number of seconds
                                            for a stream to import

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'import_database',
            'app': app,                                         # (str) (req)
            'database_path': database_path,                     # (str) (req)
            'table_name': table_name,                           # (str) (req)
            'import_ignore_interval': import_ignore_interval    # (int)
        }

        app_list = ['plexwatch', 'plexivity']
        table_name_list = ['processed', 'grouped']

        # Check keyword arguments
        utils.check_str_kw(app, app_list, is_required=True)
        utils.check_str_kw(database_path, is_required=True)
        utils.check_str_kw(table_name, table_name_list,
                           is_required=True)
        utils.check_pos_int_kw(import_ignore_interval,
                               is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def install_geoip_db(self):
        """
        Downloads and installs the GeoLite2 database
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'install_geoip_db'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def notify(self, notifier_id=None, subject=None, body=None,
               script_args=None):
        """
        Send a notification using Tautulli.

        Required parameters:
            notifier_id (int):      The ID number of the notification agent
            subject (str):          The subject of the message
            body (str):             The body of the message

        Optional parameters:
            script_args (str):      The arguments for script notifications

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'notify',
            'notifier_id': notifier_id,                         # (int) (req)
            'subject': subject,                                 # (str) (req)
            'body': body,                                       # (str) (req)
            'script_args': script_args                          # (str)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(notifier_id, is_required=True)
        utils.check_str_kw(subject, is_required=True)
        utils.check_str_kw(body, is_required=True)
        utils.check_str_kw(script_args, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def notify_newsletter(self, newsletter_id=None, subject=None, body=None,
                          message=None):
        """
        Send a newsletter using Tautulli.

        Required parameters:
            newsletter_id (int):    The ID number of the newsletter agent

        Optional parameters:
            subject (str):          The subject of the newsletter
            body (str):             The body of the newsletter
            message (str):          The message of the newsletter

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'notify_newsletter',
            'newsletter_id': newsletter_id,                     # (int) (req)
            'subject': subject,                                 # (str)
            'body': body,                                       # (str)
            'message': message                                  # (str)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(newsletter_id, is_required=True)
        utils.check_str_kw(subject, is_required=False)
        utils.check_str_kw(body, is_required=False)
        utils.check_str_kw(message, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def notify_recently_added(self, rating_key=None, notifier_id=None):
        """
        Send a recently added notification using Tautulli.

        Required parameters:
            rating_key (int):       The rating key for the media

        Optional parameters:
            notifier_id (int):      The ID number of the notification agent.
                                    The notification will send to all enabled
                                    notification agents if notifier id is not
                                    provided.

        Returns:
            json
                {"result": "success",
                 "message": "Notification queued."
                }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'notify_recently_added',
            'rating_key': rating_key,                           # (int) (req)
            'notifier_id': notifier_id                          # (int)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(rating_key, is_required=True)
        utils.check_pos_int_kw(notifier_id, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def pms_image_proxy(self, img=None, rating_key=None, width=None,
                        height=None, opacity=None, background=None,
                        blur=None, img_format=None, fallback=None,
                        refresh=None, return_hash=None):
        """
        Gets an image from the PMS and saves it to the image cache directory.

        Required parameters:
            img (str):              /library/metadata/153037/thumb/1462175060
            or
            rating_key (int):       54321

        Optional parameters:
            width (int):            300
            height (int):           450
            opacity (int):          25
            background (int):       282828
            blur (int):             3
            img_format (str):       png
            fallback (str):         "poster", "cover", "art"
            refresh (bool):         True or False whether to refresh the
                                    image cache
            return_hash (bool):     True or False to return the self-hosted
                                    image hash instead of the image

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'pms_image_proxy',
            'img': img,                                 # (str) (req, bitwise)
            'rating_key': rating_key,                   # (int) (req, bitwise)
            'width': width,                             # (int)
            'height': height,                           # (int)
            'opacity': opacity,                         # (int)
            'background': background,                   # (int)
            'blur': blur,                               # (int)
            'img_format': img_format,                   # (str)
            'fallback': fallback,                       # (str)
            'refresh': refresh,                         # (bool)
            'return_hash': return_hash                  # (bool)
        }

        fallback_list = ["poster", "cover", "art"]

        # Check for ONLY one required arguments
        if img and rating_key is None:
            raise ValueError(
                'Either "img" OR "rating_key" is required'
            )
        elif img and rating_key is not None:
            raise ValueError(
                'Only ONE required argument ("img" OR "rating_key") '
                'is required'
            )
        elif img is not None:
            utils.check_str_kw(img)
        elif rating_key is not None:
            utils.check_pos_int_kw(rating_key)

        # Check keyword arguments
        utils.check_pos_int_kw(width, is_required=False)
        utils.check_pos_int_kw(height, is_required=False)
        utils.check_pos_int_kw(opacity, is_required=False)
        utils.check_pos_int_kw(background, is_required=False)
        utils.check_pos_int_kw(blur, is_required=False)
        utils.check_str_kw(img_format, is_required=False)
        utils.check_str_kw(fallback, fallback_list, is_required=False)
        utils.check_bool_kw(refresh, is_required=False)
        utils.check_bool_kw(return_hash, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def refresh_libraries_list(self):
        """
        Refresh the Tautulli libraries list.
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'refresh_libraries_list'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def refresh_users_list(self):
        """
        Refresh the Tautulli users list.
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'refresh_users_list'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def register_device(self, device_name=None, device_id=None,
                        friendly_name=None):
        """
        Registers the Tautulli Android App for notifications.

        Required parameters:
            device_name (str):        The device name of the Tautulli
                                      Android App
            device_id (str):          The OneSignal device id of the Tautulli
                                      Android App

        Optional parameters:
            friendly_name (str):      A friendly name to identify the
                                      mobile device

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'register_device',
            'device_name': device_name,                         # (str) (req)
            'device_id': device_id,                             # (str) (req)
            'friendly_name': friendly_name                      # (str)
        }

        # Check keyword arguments
        utils.check_str_kw(device_name, is_required=True)
        utils.check_str_kw(device_id, is_required=True)
        utils.check_str_kw(friendly_name, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def restart(self):
        """
        Restart Tautulli.
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'restart',
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def search(self, query=None, limit=None):
        """
        Get search results from the PMS.

        Required parameters:
            query (str):        The query string to search for

        Optional parameters:
            limit (int):        The maximum number of items to return per
                                media type

        Returns:
            json:
                {"results_count": 69,
                 "results_list":
                    {"movie":
                        [{...},
                         {...},
                         ]
                     },
                    {"episode":
                        [{...},
                         {...},
                         ]
                     },
                    {...}
                 }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'search',
            'query': query,                                     # (str) (req)
            'limit': limit                                      # (int)
        }

        # Check keyword arguments
        utils.check_str_kw(query, is_required=True)
        utils.check_pos_int_kw(limit, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def set_mobile_device_config(self, mobile_device_id=None,
                                 friendly_name=None):
        """
        Configure an existing notification agent.

        Required parameters:
            mobile_device_id (int):        The mobile device config to update

        Optional parameters:
            friendly_name (str):           A friendly name to identify the
                                           mobile device

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'set_mobile_device_config',
            'mobile_device_id': mobile_device_id,               # (int) (req)
            'friendly_name': friendly_name                      # (str)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(mobile_device_id, is_required=True)
        utils.check_str_kw(friendly_name, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def set_newsletter_config(self, newsletter_id=None, agent_id=None,
                              newsletter_config_=None, newsletter_email_=None):
        """
        Configure an existing newsletter agent.

        Required parameters:
            newsletter_id (int):    The newsletter config to update
            agent_id (int):         The newsletter type of the newsletter

        Optional parameters:
            Pass all the config options for the agent with the
            'newsletter_config_' and 'newsletter_email_' prefix.

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'set_newsletter_config',
            'newsletter_id': newsletter_id,                     # (int) (req)
            'agent_id': agent_id,                               # (int) (req)
            'newsletter_config_': newsletter_config_,           # (str)
            'newsletter_email_': newsletter_email_              # (str)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(newsletter_id, is_required=True)
        utils.check_pos_int_kw(agent_id, is_required=True)
        utils.check_str_kw(newsletter_config_, is_required=False)
        utils.check_str_kw(newsletter_email_, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def set_notifier_config(self, notifier_id=None, agent_id=None, **cfg_opts):
        """
        Configure an existing notification agent.

        Required parameters:
            notifier_id (int):        The notifier config to update
            agent_id (int):           The agent of the notifier

        Optional parameters:
            Pass all the config options for the agent with the agent prefix:
                e.g. For Telegram: telegram_bot_token
                                   telegram_chat_id
                                   telegram_disable_web_preview
                                   telegram_html_support
                                   telegram_incl_poster
                                   telegram_incl_subject
            Notify actions (bin):  0 or 1,
                e.g. on_play, on_stop, etc.
            Notify text (str):
                e.g. on_play_subject, on_play_body, etc.

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'set_notifier_config',
            'notifier_id': notifier_id,                         # (int) (req)
            'agent_id': agent_id,                               # (int) (req)
        }

        # Check keyword arguments
        utils.check_pos_int_kw(notifier_id, is_required=True)
        utils.check_pos_int_kw(agent_id, is_required=True)

        # Pack **cfg_opts in payload
        for kw, val in cfg_opts.items():
            payload[kw] = val

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def sql(self, query=None):
        """
        Query the Tautulli database with raw SQL. Automatically makes a
        backup of the database if the latest backup is older than 24hrs.
        `api_sql` must be manually enabled in the config file.

        Required parameters:
            query (str):        The SQL query

        Optional parameters:
            None

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'sql',
            'query': query,                                     # (str) (req)
        }

        # Check keyword arguments
        utils.check_str_kw(query, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def terminate_session(self, session_key=None, session_id=None,
                          message=None):
        """
        Stop a streaming session.

        Required parameters:
            session_key (int):          The session key of the session to
                                        terminate, OR
            session_id (str):           The session id of the session to
                                        terminate

        Optional parameters:
            message (str):              A custom message to send to the client

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'terminate_session',
            'session_key': session_key,                 # (int) (req, bitwise)
            'session_id': session_id,                   # (str) (req, bitwise)
            'message': message                          # (str)
        }

        # Check for ONLY one required arguments
        if session_key and session_id is None:
            raise ValueError(
                'Either "session_key" OR "session_id" is required'
            )
        elif session_key and session_id is not None:
            raise ValueError(
                'Only ONE required argument ("session_key" OR "session_id") '
                'is required'
            )
        elif session_key is not None:
            utils.check_pos_int_kw(session_key)
        elif session_id is not None:
            utils.check_str_kw(session_id)

        # Check keyword arguments
        utils.check_str_kw(message, is_required=False)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def undelete_library(self, session_key=None, session_name=None):
        """
        Restore a deleted library section to Tautulli.

        Required parameters:
            section_id (str):       The id of the Plex library section
            section_name (str):     The name of the Plex library section

        Optional parameters:
            None

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'undelete_library',
            'session_key': session_key,                         # (str) (req)
            'session_name': session_name                        # (str) (req)
        }

        # Check keyword arguments
        utils.check_str_kw(session_key, is_required=True)
        utils.check_str_kw(session_name, is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def undelete_user(self, user_id=None, username=None):
        """
        Restore a deleted user to Tautulli.

        Required parameters:
            user_id (str):          The id of the Plex user
            username (str):         The username of the Plex user

        Optional parameters:
            None

        Returns:
            None
        """

    def uninstall_geoip_db(self):
        """
        Uninstalls the GeoLite2 database
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'uninstall_geoip_db'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def update(self):
        """
        Update Tautulli.
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'update'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def update_check(self):
        """
        Check for Tautulli updates.

        Required parameters:
            None

        Optional parameters:
            None

        Returns:
            json
                {"result": "success",
                 "update": true,
                 "message": "An update for Tautulli is available."
                }
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'update_check'
        }

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp

    def update_metadata_details(self, old_rating_key=None,
                                new_rating_key=None, media_type=None):
        """
        Update the metadata in the Tautulli database by matching rating keys.
        Also updates all parents or children of the media item if it is a
        show/season/episode or artist/album/track.

        Required parameters:
            old_rating_key (int):       12345
            new_rating_key (int):       54321
            media_type (str):           "movie", "show", "season",
                                        "episode", "artist", "album", "track"

        Optional parameters:
            None

        Returns:
            None
        """

        payload = {
            'apikey': API_KEY,
            'cmd': 'undelete_library',
            'old_rating_key': old_rating_key,                   # (int) (req)
            'new_rating_key': new_rating_key,                   # (int) (req)
            'media_type': media_type                            # (str) (req)
        }

        media_type_list = ["movie", "show", "season", "episode", "artist",
                           "album", "track"]

        # Check keyword arguments
        utils.check_pos_int_kw(old_rating_key, is_required=True)
        utils.check_pos_int_kw(new_rating_key, is_required=True)
        utils.check_str_kw(media_type, media_type_list,
                           is_required=True)

        # Send/receive request
        resp = utils.send_receive_request(self._base_url, params_dict=payload)
        return resp
